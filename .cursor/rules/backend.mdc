---
description: Backend conventions for Shop Scraper (Fastify + TypeScript)
globs: src/**/*.ts
alwaysApply: false
---

# Shop Scraper Backend Conventions

## Stack

- Runtime: Node.js 20+ with ESM
- Framework: Fastify 5.x
- ORM: Drizzle ORM (PostgreSQL)
- Validation: Zod
- Logger: Pino (Fastify built-in)
- Scraping: Playwright (headless browser)
- Testing: Vitest
- Linting: ESLint + Prettier
- Language: TypeScript (strict mode)

## Project Structure

```
src/
├── index.ts              # Entry point — creates real deps, calls buildApp, starts server, graceful shutdown
├── app.ts                # App factory — accepts deps, creates Fastify instance, registers everything, returns it
├── env.ts                # Validates process.env with Zod schema, exits on failure
├── config.ts             # Maps validated env to camelCase config object with derived values
├── db/
│   ├── index.ts          # Database factory — accepts connection string, returns db + close()
│   ├── schema.ts         # Drizzle table definitions, relations, inferred types ($inferSelect, $inferInsert)
│   └── migrate.ts        # Standalone migration runner script
├── routes/               # Route handlers — each exports async function registered via fastify.register()
├── schemas/              # OpenAPI JSON schema definitions
│   ├── index.ts          # registerSchemas() — loops all schemas, calls fastify.addSchema()
│   ├── common.ts         # ErrorResponse, Pagination schemas
│   └── *.schema.ts       # Entity-specific schemas with $id property
├── scraper/              # Playwright scraping logic
│   ├── browser.ts        # Browser lifecycle (launch/close)
│   ├── link-collector.ts # Collect product links from category page
│   ├── product-scraper.ts# Scrape data from product detail pages
│   └── selectors.ts      # CSS selectors (easy to update per-site)
├── services/             # Business logic (WooCommerce sync, scrape orchestration)
├── output/               # File output (JSON writer)
└── types/
    ├── product.ts         # Product Zod schema + inferred types
    └── fastify.d.ts       # Module augmentation for injected dependencies on FastifyInstance
```

Tests live outside `src/`:

```
tests/
├── unit/                 # Pure function tests, mocked deps, no I/O
├── integration/          # Real DB via Testcontainers, app.inject()
├── e2e/                  # Docker Compose, real HTTP fetch()
└── helpers/
    └── db.ts             # Testcontainers setup, cleanup, seed helpers
```

## Environment & Config

Two-layer approach. Never read `process.env` anywhere except `env.ts`.

### Layer 1 — Validation (`env.ts`)

```typescript
const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.coerce.number().default(3000),
  DATABASE_URL: z.string().min(1),
  SCRAPE_URL: z.url(),
  WC_STORE_URL: z.url(),
  WC_CONSUMER_KEY: z.string().min(1),
  WC_CONSUMER_SECRET: z.string().min(1),
})

const result = envSchema.safeParse(process.env)
if (!result.success) {
  console.error('Invalid environment variables:', result.error.format())
  process.exit(1)
}
export const env = result.data
```

### Layer 2 — Mapping (`config.ts`)

```typescript
import { env } from './env.js'

export const config = {
  nodeEnv: env.NODE_ENV,
  port: env.PORT,
  databaseUrl: env.DATABASE_URL,
  isDev: env.NODE_ENV !== 'production',
  scrapeUrl: env.SCRAPE_URL,
  wcStoreUrl: env.WC_STORE_URL,
  wcConsumerKey: env.WC_CONSUMER_KEY,
  wcConsumerSecret: env.WC_CONSUMER_SECRET,
} as const
```

### Rules

- Routes and services only import `config`, never `env`
- Always update `.env.example` when adding new env vars (without actual values)

## App Factory & Dependency Injection

### Dependency Interface

```typescript
interface AppDependencies {
  db: Database
}
```

### Factory Function (`app.ts`)

```typescript
export async function buildApp(deps: AppDependencies) {
  const fastify = Fastify({ logger: true })
  fastify.decorate('db', deps.db)
  await registerSchemas(fastify)
  await fastify.register(routes)
  return fastify
}
```

### Type Augmentation (`types/fastify.d.ts`)

```typescript
import type { Database } from '../db/index.js'

declare module 'fastify' {
  interface FastifyInstance {
    db: Database
  }
}
```

### Production Wiring (`index.ts`)

```typescript
const { db, close: closeDb } = createDb(config.databaseUrl)
const app = await buildApp({ db })
await app.listen({ port: config.port, host: '0.0.0.0' })

const shutdown = async () => {
  await app.close()
  await closeDb()
  process.exit(0)
}
process.on('SIGINT', shutdown)
process.on('SIGTERM', shutdown)
```

### Rules

- Routes access deps via Fastify context (`fastify.db`), never import directly
- Entry point (`index.ts`) creates real services and passes them to `buildApp`
- Tests create their own services (mocks or Testcontainers)
- No test-specific code in production files
- `buildApp` never calls `listen()` — only `index.ts` does that

### Adding a New Injectable Service

1. Create a factory function: accepts config, returns instance + `close()`
2. Add service type to `AppDependencies`
3. Add `fastify.decorate('serviceName', deps.serviceName)` in `buildApp`
4. Add the type to `FastifyInstance` in `fastify.d.ts`
5. Create the real instance in `index.ts` and pass it to `buildApp`
6. Access in routes via `fastify.serviceName`

## Routes & Request Handling

Each route file exports an async function registered via `fastify.register()`:

```typescript
export async function productRoutes(fastify: FastifyInstance) {
  fastify.get('/products', {
    schema: {
      tags: ['products'],
      response: {
        200: { $ref: 'ProductList#' },
        500: { $ref: 'ErrorResponse#' },
      },
    },
  }, async (request, reply) => {
    try {
      const products = await fastify.db.select().from(productsTable)
      return products
    } catch (err) {
      request.log.error({ err }, 'failed to fetch products')
      return reply.status(500).send({ message: 'Internal server error' })
    }
  })
}
```

### Rules

- Access deps through `fastify.db`, never import directly
- Use `request.log` for request-scoped logging (includes request ID)
- Reference OpenAPI schemas via `$ref`, never define inline
- Distinguish connection errors (503) from other failures (500)
- Use `app.inject()` in tests, not real HTTP

## OpenAPI Schema Management

### Schema File Convention

```typescript
export const productSchema = {
  $id: 'Product',
  type: 'object',
  properties: {
    id: { type: 'integer' },
    name: { type: 'string' },
    sku: { type: 'string' },
    price: { type: 'string' },
    imageUrl: { type: 'string', nullable: true },
  },
  required: ['id', 'name', 'sku', 'price'],
} as const
```

### Registration (`schemas/index.ts`)

```typescript
import { productSchema } from './product.schema.js'
import { errorResponseSchema } from './common.js'

const schemas = [productSchema, errorResponseSchema]

export function registerSchemas(fastify: FastifyInstance) {
  for (const schema of schemas) {
    fastify.addSchema(schema)
  }
}
```

### Schema Types Reference

| Field Type   | Schema                                            |
| ------------ | ------------------------------------------------- |
| UUID         | `{ type: 'string', format: 'uuid' }`             |
| Timestamp    | `{ type: 'string', format: 'date-time' }`        |
| Nullable     | `{ type: 'string', nullable: true }`              |
| Enum         | `{ type: 'string', enum: ['a', 'b'] }`           |
| Ref          | `{ $ref: 'SchemaName#' }`                         |
| Nullable ref | `{ oneOf: [{ $ref: 'Schema#' }, { type: 'null' }] }` |

### After API Changes

1. Run `npm run openapi:generate`
2. Commit updated `docs/openapi.json`

## API Response Codes

- 200: GET, PATCH success
- 201: POST success
- 204: DELETE success
- 400: Validation error
- 404: Resource not found
- 500: Internal server error
- 503: Database/service unavailable

## Error Format

```typescript
{ message: "Human-readable error description" }
```

## Logging

Use Fastify's built-in Pino logger:

- `request.log` in route handlers (includes request ID)
- `fastify.log` in plugins/hooks
- **error**: Exceptions, failed operations
- **warn**: Retry attempts, edge cases
- **info**: Data mutations (create, update, delete)

```typescript
request.log.info({ productId, action: 'created' }, 'product created')
request.log.error({ err, productId }, 'failed to delete product')
```

## TypeScript

- Strict mode (`"strict": true`)
- No implicit any (`"noImplicitAny": true`)
- ESM modules (`"module": "NodeNext"`)
- Use Drizzle `$inferSelect` / `$inferInsert` types — never hand-write interfaces for DB entities

## Code Style

- No comments (exception: complex "why" logic)
- No `// ... rest of code` placeholders
- Pin all dependency versions exactly (no `^` or `~`)
- Single quotes, no semicolons, 2-space indent, trailing commas
